// Подключаем заголовочный файл класса Base для реализации методов, объявленных в Base.h
#include "Base.h"

// Конструктор по умолчанию класса Base: использует список инициализации для установки начального значения поля name
Base::Base() : name("Unknown") {
    // Вывод отладочной информации в консоль, показывает, что конструктор по умолчанию был вызван
    std::cout << "Base default constructor called for: " << name << std::endl;
}

// Конструктор с параметрами класса Base, принимает константную ссылку на строку (эффективно, избегает копирования),инициализирует поле name значением параметра name
Base::Base(const std::string& name) : name(name) {
    // Вывод отладочной информации с переданным именем
    std::cout << "Base parameterized constructor called for: " << name << std::endl;
}

// Конструктор копирования класса Base: принимает константную ссылку на другой объект Base, создает новый объект как копию существующего, инициализирует поле name значением из объекта other
Base::Base(const Base& other) : name(other.name) {
    // Вывод отладочной информации о копировании
    std::cout << "Base copy constructor called for: " << name << std::endl;
}

// Деструктор класса Base, автоматически вызывается при уничтожении объекта
Base::~Base() {
    // Вывод отладочной информации об уничтожении объекта
    std::cout << "Base destructor called for: " << name << std::endl;
}

// Перегрузка оператора присваивания для класса Base, принимает константную ссылку на другой объект Base, возвращает ссылку на текущий объект (для цепочки присваиваний a = b = c)
Base& Base::operator=(const Base& other) {
    // Проверка на самоприсваивание (a = a)
    if (this != &other) {
        // Копируем данные из other в текущий объект, присваиваем полю name значение name из объекта other
        name = other.name;
    }
    // Вывод отладочной информации о выполнении присваивания, показывает, когда объекты присваиваются друг другу
    std::cout << "Base assignment operator called for: " << name << std::endl;
    // Возвращаем ссылку на текущий объект, позволяет создавать цепочки присваиваний: a = b = c
    return *this;
}

// Метод для получения имени (getter): const - гарантирует, что не изменяет состояние объекта
std::string Base::getName() const {
    // Возвращаем копию строки name
    return name;
}

// Метод для установки имени (setter), принимает константную ссылку на новое имя, изменяет значение поля name
void Base::setName(const std::string& name) {
    // this->name обращается к полю класса
    this->name = name;
}
